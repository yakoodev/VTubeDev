# VTube MVP — подробная roadmap (декомпозиция + критерии приёмки)

Источник требований: **«VTube — архитектурный холст (MVP)»**. fileciteturn0file0

> Документ — план реализации MVP **на Windows**, с маленькими задачами и чёткими критериями приёмки.
> Формат: **Этап → Эпик → Набор задач**. У каждой задачи есть артефакты и критерии приёмки.

---

## 0) Глоссарий (коротко, чтобы не путаться)
- **cameraId** — источник 3D-рендера + композитинга слоёв.
- **formatId** — финальный кадр (crop/scale + overlay + output profile), может быть derived от `RT_Base(cameraId)`.
- **RT_Base(cameraId)** — базовый рендер-таргет камеры после 3D+2D+силуэтов.
- **RT_Overlay(formatId)** — слой UI/оверлея для конкретного формата.
- **Output profile** — параметры выдачи (fps, jpegQuality, idleTimeout, includeTags).
- **SceneCommand** — единый язык управления сценой (UI/интеграции/плагины).
- **DataStore** — единый источник данных для UI/оверлеев/интеграций (`scene.*`, `vars.*`, и т.д.).
- **Derived format** — формат, который не требует отдельного 3D-рендера (берёт `RT_Base` и делает crop/scale).

---

## 1) Принципы MVP (Definition of Done уровня продукта)
### Обязательные свойства
1. **Детерминированный порядок рендера** через URP RendererFeature/Pass.
2. **Разделение Camera vs Format**: derived форматы не триггерят отдельный 3D render.
3. **UI overlay per-format**: debug/release профили отличаются тегами.
4. **Web endpoints**: `/view`, `/stream`, `/snapshot`, `/api/streams`, `/api/health`, `/api/metrics`.
5. **On-demand рендер**: формат активируется только при наличии потребителя (view/stream/окно/replay).
6. **Плагины DLL**: загрузка через reflection, DI, изоляция try/catch.
7. **Интеграции**: Twitch chat + Webhook + Hotkeys через Envelope → Rules → SceneCommand → Audit.
8. **Трекинг**: MediaPipe как MVP трекер (node-driven data graph).
9. **Replay**: ring buffer (по умолчанию 120s), NVENC H.264, контейнер MKV.
10. **Сохранение состояния**: `workspace.json` локально, `.env` для секретов, экспорт проекта как архив `.vtproj`.

### Непривязанные к MVP (явно «позже»)
- HTML overlay-рендер (интерфейс есть, реализация позже).
- Strict/Off режимы silhouette (в MVP только default Silhouette).
- Полноценный node editor (в MVP read-only визуализация).
- Spawn «с нуля» без templates (в MVP только templates).

---

## 2) Этапы (вехи) MVP
- **Этап A — База проекта и каркас runtime**: конфиги, DI, логирование, DataStore, сериализация.
- **Этап B — Рендер-цепочка (URP) + сцена (камеры/форматы/слои)**.
- **Этап C — Overlay (Unity UI) + overlay.json + биндинги**.
- **Этап D — Web Streaming Endpoints + профили выдачи + on-demand**.
- **Этап E — Orchestrator (UI+API) + роли/токены + audit**.
- **Этап F — Интеграции + Rule Engine + SceneCommand v0.1**.
- **Этап G — Tracking (MediaPipe) + Data Graph**.
- **Этап H — Replay (ring buffer + NVENC)**
- **Этап I — Тестирование (unit + рендер-регрессии) + packaging/export/migrations**.

> В каждом этапе есть epics и мелкие задачи. Порядок — рекомендуемый, чтобы не блокировать поздние части.

---

# Этап A — База проекта и каркас runtime

## Epic A1 — Структура проекта, DI, конфиги
### A1.1 Создать репозиторную структуру и договоры папок
**Артефакты:** структура директорий (Unity + .NET), соглашения по `vtproj`, `workspace.json`, `.env`  
**Критерии приёмки:**
- В репо есть папки/плейсхолдеры: `app/`, `unity/`, `shared/`, `docs/`, `examples/`.
- Чётко определены пути: `ui/overlays/<overlayProfileId>/`, `outputs/`, `assets/templates/`.
- Есть README с кратким «как запустить локально» (Windows).

### A1.2 Базовый контейнер зависимостей (DI)
**Артефакты:** `ServiceCollection` / composition root, интерфейсы сервисов  
**Критерии приёмки:**
- Сервисы регистрируются единообразно (singleton/scoped/transient по правилам).
- Есть smoke-тест: «подняли контейнер → все обязательные сервисы разрешились».
- Плагины могут регистрировать сервисы через `IPluginContext` (пока пустой интерфейс, но контракт есть).

### A1.3 Единый конфиг-лоадер + валидация схем
**Артефакты:** загрузка json-конфигов, минимальная валидация версий  
**Критерии приёмки:**
- Поддержаны версии: `overlayFormatVersion: 1.0`, `dataStoreVersion: 1.0` (строгая проверка строк).
- При несовместимой версии — понятная ошибка (лог + UI/консоль сообщение).
- В тестах: загрузка валидного конфига проходит, некорректного — падает ожидаемо.

### A1.4 Логирование и уровни (runtime + web)
**Артефакты:** логгер, уровни, корреляция запросов  
**Критерии приёмки:**
- Есть минимум: Trace/Debug/Info/Warn/Error.
- Web-запросы получают `requestId`, который отображается в логах.
- Ошибки плагинов логируются как отдельная категория `Plugin`.

---

## Epic A2 — DataStore v1.0 (ядро данных)
### A2.1 Определить модель данных и контракт доступа
**Артефакты:** структура `scene/integrations/replay/vars/performance/system`, API для get/set по path  
**Критерии приёмки:**
- Можно читать/писать по строковому пути (`vars.foo.bar`).
- Запись в `vars.*` разрешена всем (rules/plugins/UI).
- Есть ограниченная типизация: string/number/bool/object/array (или JsonElement).

### A2.2 Подписки и события изменения
**Артефакты:** `IDataStore.Subscribe(pathPrefix, handler)`  
**Критерии приёмки:**
- Подписчик получает события при изменениях (с old/new либо diff).
- Есть debounce/очередь, чтобы массовые обновления не «убивали» UI (минимально: coalesce по кадру/тик).
- Тест: подписка на `scene.*` ловит обновление при `scene.camera.active=true`.

### A2.3 Снимок DataStore для overlay/стриминга
**Артефакты:** `IDataStore.Snapshot()` / сериализация в JSON  
**Критерии приёмки:**
- Snapshot стабилен по структуре (одинаковый порядок ключей не обязателен, но валидный JSON обязателен).
- Snapshot не падает при больших объёмах данных (минимально: 10k записей в `vars.*`).
- Есть лимитер объёма (на MVP допускается настройка «на совести пользователя», но механизм параметров есть).

---

## Epic A3 — Runtime state vs Project state
### A3.1 Определить формат `workspace.json` и правила слияния
**Артефакты:** схема workspace, функции merge runtime → project state  
**Критерии приёмки:**
- `workspace.json` хранится локально и восстанавливается при запуске.
- Live-изменения по умолчанию runtime-only.
- Save/Save As выполняет merge и фиксирует «текущую реальность» как проект.

### A3.2 Undo/Redo для проектных правок
**Артефакты:** стек undo/redo, область действия (только project state)  
**Критерии приёмки:**
- Команды undo/redo не затрагивают runtime-only переключения.
- В тестах: 10 последовательных операций откатываются и возвращаются вперёд без рассинхрона.

### A3.3 Audit лог (минимальный каркас)
**Артефакты:** запись: кто/что/когда/результат + payload snapshot (по необходимости)  
**Критерии приёмки:**
- Любой SceneCommand записывает audit entry (source/actorId/priority/timestamp/result).
- Есть возможность отключить «слишком жирные» payload’ы (настройка).

---

# Этап B — Рендер-цепочка (URP) + сцена

## Epic B1 — Модель сцены (камеры/форматы/слои)
### B1.1 Реестр камер (cameraId) и их конфиги
**Артефакты:** `CameraRegistry`, `camera.json`/часть `scene.json` (по выбранной структуре)  
**Критерии приёмки:**
- Можно создать/удалить/включить/выключить камеру в runtime.
- Камера имеет параметры: разрешение базового рендера, bufferize (для replay), ссылку на базовый формат.
- В логах видно, какая камера активна и почему (потребитель/буфер).

### B1.2 Реестр форматов (formatId) + derived
**Артефакты:** `FormatRegistry`, `formats.json`, флаг `derived`  
**Критерии приёмки:**
- Derived формат определяется без отдельного 3D-рендера.
- Формат знает: crop/scale, overlayProfileId, output profile ссылку.
- Тест: derived формат при включении не увеличивает число камерных рендер-проходов.

### B1.3 Слои и подслои сцены
**Артефакты:** модель `Layer/SubLayer`, порядок, видимость, enable  
**Критерии приёмки:**
- Слои сортируются детерминированно (order + tie-breaker по id).
- Можно включать/выключать слои SceneCommand’ами.
- Подслои применяются (для параллакса/группировки) минимум на уровне структуры данных.

---

## Epic B2 — URP pipeline: Base 3D + 2D/hybrid + silhouette + post
### B2.1 ScriptableRendererFeature каркас
**Артефакты:** URP RendererFeature + Pass’ы с фиксированным порядком  
**Критерии приёмки:**
- Порядок Pass’ов соответствует холсту: Base3D → Hybrid2D → SilhouetteDepth → Post+Overlay → Outputs.
- Pass’ы включаются/выключаются по необходимости (on-demand).
- Есть debug-режим, выводящий в лог порядок и активность pass’ов по камере/формату.

### B2.2 RT_Base(cameraId): создание и управление RenderTexture
**Артефакты:** аллокатор RT, reuse/pooling  
**Критерии приёмки:**
- RT создаётся с корректным размером и форматом (URP-friendly).
- При смене разрешения RT пересоздаётся без утечек (проверка профайлером).
- При выключении камеры RT освобождается/возвращается в пул.

### B2.3 2D/Hybrid Layer Pass: multi-plane RenderItems + blend modes
**Артефакты:** RenderItem (2D), материалы/шейдеры для Normal/Add/Multiply/Screen  
**Критерии приёмки:**
- 2D-слои рисуются поверх 3D в `RT_Base`.
- У каждого RenderItem есть blendMode из списка MVP.
- В тестовой сцене есть 4 слоя с разными blend’ами, визуально различимы.

### B2.4 Clipping: 1 маска на RenderItem
**Артефакты:** mask texture/shape + alpha clip  
**Критерии приёмки:**
- Маска применяется только к своему RenderItem.
- Маска корректно работает на разных scale/anchor (в пределах кадра).
- Отсутствие маски не ломает рендер (default = no clip).

### B2.5 Outline (включён в MVP)
**Артефакты:** outline-проход/шейдер или материалный эффект  
**Критерии приёмки:**
- Outline можно включать/выключать на RenderItem/слое.
- Толщина/цвет задаются параметрами (минимально: толщина + интенсивность, можно без UI пока).
- В демо видно, что outline не «съедает» прозрачности.

### B2.6 Silhouette Depth Write (default Silhouette)
**Артефакты:** pass, alpha-clip depth write по маске при `silhouetteWrite=true`  
**Критерии приёмки:**
- Для отмеченных 2D-слоёв глубина пишется так, чтобы 3D мог перекрывать/перекрываться ожидаемо.
- Отсутствие `silhouetteWrite` не меняет depth.
- В демо: 3D-объект корректно перекрывает часть 2D-персонажа по маске.

### B2.7 Post + UI Overlay per format: базовый композитор
**Артефакты:** per-format pipeline: crop/scale → overlay → output  
**Критерии приёмки:**
- Пост применяется к скомпоженному кадру (3D+2D+silhouette), как в ТЗ.
- Crop/scale работает для разных aspect ratio.
- На output видно UI overlay соответствующего `overlayProfileId`.

---

## Epic B3 — Data Graph: webcam → tracker → filters → ParameterSet → bindings.json
### B3.1 Контракт узлов (Node) и графа
**Артефакты:** `INode`, `GraphRunner`, типы портов/значений  
**Критерии приёмки:**
- Граф выполняется 1 раз за кадр в Update, до применения SceneCommand.
- Узлы имеют стабильные id, сериализуются в JSON.
- При ошибке узла — граф не «падает целиком», а деградирует (лог + значение по умолчанию).

### B3.2 ParameterSet как результат графа
**Артефакты:** структура ParameterSet (словарь параметров)  
**Критерии приёмки:**
- ParameterSet содержит значения, которые потом маппятся в bindings.
- Поддержаны типы: float/bool/int/vector2/vector3 (минимально: float/bool для MVP, остальное можно stub).
- Есть пример параметров: `face.smile`, `face.blinkL`, `face.blinkR`.

### B3.3 `bindings.json`: параметры → деформации/трансформы/материалы
**Артефакты:** binding engine, маппинг path → target  
**Критерии приёмки:**
- Биндинг может писать в Transform/Material property (минимум 2 типа таргетов).
- Биндинг применяет clamp/scale (минимально: scale + offset).
- В демо: улыбка меняет blendshape/скейл, моргание меняет прозрачность слоя.

### B3.4 Очередь `SceneCommand` применяется после графа
**Артефакты:** порядок Update: Graph → Bindings → Commands  
**Критерии приёмки:**
- Из логов понятно, что команды применились после биндингов (и почему так).
- Конфликтующие команды (priority) не теряются — фиксируются в логах/аудите.

---

# Этап C — Overlay (Unity UI) + overlay.json + биндинги

## Epic C1 — Формат `overlay.json` (v1.0) и загрузка профилей
### C1.1 Парсер overlay.json и модель виджетов
**Артефакты:** модели: design/scaling/safeArea/widgets/tags/bindings/font  
**Критерии приёмки:**
- Поддержаны поля MVP: `Text/Image/ProgressBar/FeedList/DebugHUD`.
- Неизвестные поля игнорируются (или логируются), но не ломают загрузку.
- Некорректный JSON/версия даёт понятную ошибку.

### C1.2 Система тегов debug/release
**Артефакты:** фильтрация `widgets[]` по `includeTags` output profile  
**Критерии приёмки:**
- `tags:["debug"]` видны только в debug-профиле.
- В release-профиле debug-виджеты гарантированно не рендерятся.
- В демо overlay есть хотя бы один debug-only элемент (например FPS).

### C1.3 Ресолв ассетов (картинки/шрифты) внутри overlayProfile
**Артефакты:** загрузчик `assets/` (fonts/images)  
**Критерии приёмки:**
- Если шрифт не найден — используется дефолтный, и это логируется один раз.
- Картинки грузятся из `ui/overlays/<id>/assets/`.
- При отсутствии ассета виджет не рушит сцену (показывается placeholder/пропуск + лог).

---

## Epic C2 — IOverlayRenderer и Unity-реализация
### C2.1 Интерфейс `IOverlayRenderer`
**Артефакты:** интерфейс + переключатель реализации  
**Критерии приёмки:**
- Есть контракт: `Render(formatId, profile, dataSnapshot) -> RT_Overlay` (или аналог).
- Unity-реализация подключена по умолчанию.
- Возможность заменить реализацию (хотя бы через DI).

### C2.2 Layout engine: RectTransform-подобные anchors/pivot/posPx/sizePx
**Артефакты:** вычисление позиций из design-resolution в target-resolution  
**Критерии приёмки:**
- `scaling.mode: fit|fill|stretch` влияет на итоговый скейл.
- `snapToPixels` работает (позиции округляются).
- В демо: один и тот же overlay корректно выглядит на 16:9 и 9:16.

### C2.3 Реализация виджетов MVP
**Артефакты:** Unity префабы/создание на лету для Text/Image/ProgressBar/FeedList/DebugHUD  
**Критерии приёмки:**
- Text поддерживает `textTemplate` и `valuePath`.
- ProgressBar отображает значение 0..1 из `valuePath`.
- FeedList умеет рендерить список по `itemsPath` (минимально: последние N строк).

---

## Epic C3 — Data binding для overlay (DataStore → UI)
### C3.1 ValuePath/itemsPath резолвер
**Артефакты:** резолв путей `scene.*`/`vars.*` и т.д.  
**Критерии приёмки:**
- Для отсутствующего пути возвращается null/дефолт (без исключений).
- Поддержка простых индексов массива (если надо для FeedList) или ограничение описано явно.
- Тест: `vars.counter` обновляет Text в overlay в течение 1 кадра/тика.

### C3.2 TextTemplate мини-шаблонизатор
**Артефакты:** подстановка `{value}` / `{path}` или простой mustache-подобный синтаксис  
**Критерии приёмки:**
- В template можно вставлять 1..N значений.
- Числа форматируются предсказуемо (по умолчанию invariant/ru-RU — выбрать и зафиксировать).
- Ошибка шаблона не крашит рендер, а показывает fallback текст + лог.

### C3.3 DebugHUD
**Артефакты:** виджет, который показывает performance/system/replay метрики  
**Критерии приёмки:**
- В debug профиле видно хотя бы: FPS, количество активных форматов/клиентов, время кадра.
- В release профиле DebugHUD не отображается (тег debug).

---

# Этап D — Web Streaming Endpoints + output profiles + on-demand

## Epic D1 — Web-сервер в десктопе (локальный сервис)
### D1.1 Встроенный HTTP сервер (Kestrel/аналоги) + конфиг портов
**Артефакты:** запуск/останов сервера, конфиг порта, bind localhost  
**Критерии приёмки:**
- По умолчанию слушает только `127.0.0.1`.
- Порт настраиваем (конфиг/аргумент).
- `/api/health` отдаёт 200 и версию приложения.

### D1.2 `/api/metrics` (минимальный набор)
**Артефакты:** JSON метрики: активные форматы, клиенты, fps, render ms  
**Критерии приёмки:**
- Endpoint стабильный (не падает) даже без активных форматов.
- Метрики обновляются в реальном времени (не реже 1 раза/сек).

---

## Epic D2 — Endpoints MVP (view/stream/snapshot/api/streams)
### D2.1 `/api/streams` — список стримов и URL
**Артефакты:** JSON список форматов + ссылки для debug/release  
**Критерии приёмки:**
- Отдаёт formatId, доступные профили, итоговые URL.
- Учитывает remote/localhost режим (если remote выключен — URL только localhost).

### D2.2 `/snapshot/<formatId>/<profile>.png`
**Артефакты:** выдача последнего кадра как PNG  
**Критерии приёмки:**
- Если кадра ещё нет — отдаёт 404 или placeholder (поведение фиксировано в доке).
- Если кадр есть — возвращает корректный PNG с правильным размером формата.
- В логах фиксируется время отдачи и размер.

### D2.3 `/stream/<formatId>/<profile>.mjpg` — MJPEG поток
**Артефакты:** MJPEG encoder, loop с кадрами, slow-client policy (drop old)  
**Критерии приёмки:**
- Поток открывается в браузере/OBS и отображает движущуюся картинку.
- При медленном клиенте кадры дропаются (клиент видит самый свежий, задержка не растёт бесконечно).
- Параметры качества/фпс берутся из output profile.

### D2.4 `/view/<formatId>/<profile>` — HTML viewer
**Артефакты:** простая HTML-страница, которая подключает MJPEG/обновляет snapshot  
**Критерии приёмки:**
- Страница открывается в OBS Browser Source и показывает stream.
- Есть индикатор статуса (loading/error) — можно минимальный.
- В debug-режиме (debug profile) видны debug-теги overlay.

---

## Epic D3 — Output Profiles (`outputs/profiles.json`)
### D3.1 Модель профиля и загрузка
**Артефакты:** `fps`, `jpegQuality`, `maxViewers?`, `idleTimeoutSec`, `includeTags`  
**Критерии приёмки:**
- Профили валидируются (fps > 0, jpegQuality 1..100, idleTimeout >= 0).
- Формат ссылается на профиль по id.
- Профиль можно переиспользовать между форматами.

### D3.2 Idle timeout и лимит зрителей
**Артефакты:** счетчик активных подключений, таймер простоя, maxViewers  
**Критерии приёмки:**
- При превышении maxViewers новые подключения отклоняются с понятным статусом.
- После idleTimeout без потребителей формат деактивируется (рендер/энкод остановлены).

---

## Epic D4 — On-demand activation (форматы/камеры)
### D4.1 Модель «потребителей» и референс-счётчики
**Артефакты:** consumers: stream/view/window/replay  
**Критерии приёмки:**
- Если нет потребителей — не происходит рендер и энкод (проверка метрик/логов).
- При появлении потребителя pipeline поднимается за предсказуемое время (без ручных действий).
- Replay bufferize держит камеру активной всегда, даже без клиентов.

### D4.2 Окно вывода (для OBS Window Capture) — fallback
**Артефакты:** окно вывода per-format (или общий менеджер окон)  
**Критерии приёмки:**
- Можно открыть окно на `formatId`.
- Окно считается потребителем (формат активируется).
- Закрытие окна корректно снимает потребителя.

---

# Этап E — Web-orchestrator (UI + API) + роли/токены + audit

## Epic E1 — Роли: Owner/Moderator/Viewer
### E1.1 Модель акторов и ролей
**Артефакты:** role model, actorId, права на команды  
**Критерии приёмки:**
- Owner может всё, Moderator ограниченно, Viewer только view.
- Попытка запрещённого действия даёт понятный ответ (403 + сообщение).

### E1.2 Инвайт-токены (Bearer) + токен в URL для Browser Source
**Артефакты:** генерация токена, срок/отзыв (минимально), формат URL  
**Критерии приёмки:**
- Remote доступ выключен по умолчанию; включается явно.
- При включении remote доступ требует токен.
- Токен в URL работает для `/view` и `/stream` (без заголовков).

### E1.3 Аудит-лог по действиям API
**Артефакты:** запись успешных/неуспешных запросов  
**Критерии приёмки:**
- В audit есть: actorId, endpoint, результат, timestamp.
- Ошибки авторизации и превышение лимитов тоже фиксируются.

---

## Epic E2 — UI управления (минимальный desktop/web UI)
### E2.1 Страница списка форматов/стримов
**Артефакты:** UI, использующий `/api/streams`  
**Критерии приёмки:**
- Пользователь видит список formatId и кнопки «открыть viewer», «копировать ссылку».
- Для debug/release доступны отдельные ссылки.

### E2.2 Управление overlayProfileId per-format
**Артефакты:** UI переключатель профиля + команда `Format.SetOverlayProfile`  
**Критерии приёмки:**
- Переключение отражается в output в течение 1–2 секунд.
- Изменение записывается в audit.

### E2.3 Read-only Node editor (визуализация графа)
**Артефакты:** UI визуализации графа без редактирования  
**Критерии приёмки:**
- UI корректно отображает ноды и связи из конфига.
- Нет возможности менять граф (read-only).
- При ошибке парсинга графа UI показывает сообщение, не крашится.

---

# Этап F — Интеграции + Rule Engine + SceneCommand v0.1

## Epic F1 — SceneCommand v0.1 (контракт + очередь)
### F1.1 Спецификация команд (MVP-группы)
**Артефакты:** перечисление команд `Layer.*`, `Camera.*`, `Format.*`, `Character.*`, `Fx.*`, `Object.*`, `Replay.*`  
**Критерии приёмки:**
- Команды сериализуются в JSON (для логов/аудита/интеграций).
- Каждая команда имеет schema/валидацию (минимальную).
- При неизвестной команде — отказ + запись в audit.

### F1.2 Очередь команд: priority + конфликты
**Артефакты:** очередь `SceneCommandQueue`, политика конфликтов  
**Критерии приёмки:**
- Команды имеют `source/actorId/priority/timestamp`.
- Конфликтующие команды видны в логах (кто победил и почему).
- При burst’е (например 100 команд/сек) очередь не деградирует неконтролируемо (минимально: лимит/батчинг).

### F1.3 Исполнитель команд (SceneCommandExecutor)
**Артефакты:** применение к runtime state + запись в audit  
**Критерии приёмки:**
- `Layer.Enable/Disable` меняет видимость в рендере.
- `Format.SetOverlayProfile` меняет overlay в output.
- `Replay.Trigger` стартует сохранение (см. этап H).

---

## Epic F2 — EventEnvelope + Normalizer
### F2.1 Контракт EventEnvelope
**Артефакты:** структура `eventId/source/type/timestamp/actor/payload/tags`  
**Критерии приёмки:**
- Любой источник событий приводит событие к Envelope.
- Envelope содержит timestamp в UTC и actor (если применимо).
- `eventId` уникален (на уровне источника, с префиксом).

### F2.2 Normalizer для Twitch/Webhook/Hotkeys
**Артефакты:** три адаптера → Envelope  
**Критерии приёмки:**
- Каждый адаптер покрыт unit-тестом (минимум 3 сценария на источник).
- Payload нормализован и не содержит секретов (tokens/keys не логируются).

---

## Epic F3 — Rule Engine
### F3.1 Мини-DSL или правилки в JSON (выбор фиксируется)
**Артефакты:** формат правил, загрузка, валидация  
**Критерии приёмки:**
- Правило может матчить по `source/type/tags` и полям payload.
- Правило выдаёт `SceneCommand[]`.
- Невалидное правило не ломает весь движок (отключается + лог).

### F3.2 Исполнение правил + запись результата в audit
**Артефакты:** pipeline: Envelope → RuleEngine → commands → queue → audit  
**Критерии приёмки:**
- Для тестового события генерируется ожидаемый набор команд.
- Audit фиксирует: какое правило сработало и какие команды выпустило.

---

## Epic F4 — Интеграции MVP
### F4.1 Twitch chat (MVP)
**Артефакты:** подключение, чтение сообщений, преобразование в Envelope  
**Критерии приёмки:**
- Сообщения чата появляются в системе как события с actor=юзер.
- Обрыв соединения восстанавливается (минимально: retry с backoff).
- Секреты хранятся в `.env`/локальном хранилище, не попадают в проект.

### F4.2 Generic Webhook (MVP)
**Артефакты:** endpoint приема событий + shared secret (опционально)  
**Критерии приёмки:**
- Endpoint принимает POST и конвертирует в Envelope.
- Есть защита от мусора (лимит размера тела, rate limit минимальный).
- При invalid подписи/секрете — отказ + audit.

### F4.3 Hotkeys (MVP)
**Артефакты:** регистрация горячих клавиш, события → Envelope  
**Критерии приёмки:**
- Можно назначить хоткей на `Replay.Trigger` и `Fx.Trigger`.
- Хоткей работает, когда приложение в фокусе (глобальные хоткеи можно позже, если сложно).

---

# Этап G — Tracking (MediaPipe) + Data Graph

## Epic G1 — Интеграция MediaPipe как трекера
### G1.1 Узел Webcam input
**Артефакты:** захват камеры, выдача кадров в граф  
**Критерии приёмки:**
- Камера выбирается из списка устройств.
- Есть fallback при недоступности (ошибка + no-op).
- FPS/размер кадра настраиваем (минимально через конфиг).

### G1.2 Узел MediaPipe tracker
**Артефакты:** обработка кадров → face landmarks/expressions (что доступно)  
**Критерии приёмки:**
- Узел выдаёт набор параметров (smile/blink/…).
- При временном отсутствии лица — параметры возвращаются в нейтральное состояние (или удерживаются — выбранная политика фиксируется).
- Ошибка трекера не валит весь граф.

### G1.3 Узлы фильтров/сглаживания (минимальный набор)
**Артефакты:** low-pass / clamp / deadzone  
**Критерии приёмки:**
- Фильтр можно настроить параметрами (alpha/threshold).
- На демо видно, что дрожание уменьшилось.

---

# Этап H — Replay (ring buffer + NVENC)

## Epic H1 — Ring buffer кадров по камере
### H1.1 Буферизация 1 формата на камеру
**Артефакты:** ring buffer N секунд, хранение кадров/времени  
**Критерии приёмки:**
- При `camera.bufferize=true` камера всегда активна.
- Буфер хранит последние N секунд (по умолчанию 120), старые кадры перезаписываются.
- Буфер не растёт по памяти бесконечно (фиксированный размер).

### H1.2 Триггеры replay: UI + hotkey
**Артефакты:** команды `Replay.Trigger`, UI кнопка, хоткей  
**Критерии приёмки:**
- Нажатие триггера сохраняет последний интервал (например 10–15 секунд, параметризуемо).
- Два триггера подряд не ломают систему (очередь заданий/лок).

---

## Epic H2 — Кодирование NVENC H.264 (AVC) в MKV
### H2.1 Интеграция энкодера (NVENC)
**Артефакты:** модуль кодирования, проверка наличия NVENC  
**Критерии приёмки:**
- На поддерживаемой GPU кодирование работает и создаёт файл.
- Если NVENC недоступен — понятный фоллбек: ошибка + отказ (или software encoder — если решите, но тогда это отдельная задача).
- Параметры (битрейт/фпс) заданы разумными дефолтами и настраиваются.

### H2.2 Путь сохранения (Videos) + именование файлов
**Артефакты:** выбор папки, шаблон имени `VTube_<date>_<time>_<cameraId>.mkv`  
**Критерии приёмки:**
- Файл появляется в папке пользователя.
- Имя уникально (при коллизии добавляется суффикс).
- В audit фиксируется путь и результат.

---

# Этап I — Тестирование + packaging/export/migrations

## Epic I1 — Engine-agnostic unit tests (.NET)
### I1.1 Тесты сериализации конфигов
**Артефакты:** unit tests: overlay.json, outputs/profiles.json, граф, SceneCommand  
**Критерии приёмки:**
- Валидные примеры проходят.
- Невалидные примеры падают ожидаемо и проверяются на тексты ошибок.

### I1.2 Тесты Rule Engine и очереди команд
**Артефакты:** тесты конфликтов priority, матчинг правил  
**Критерии приёмки:**
- При одинаковой команде от разных источников побеждает по priority/времени согласно политике.
- Результат фиксируется в логах (тест проверяет, что событие есть).

---

## Epic I2 — Рендер-регрессии: PNG snapshots vs golden
### I2.1 CLI/режим тестового рендера
**Артефакты:** headless/авто-режим запуска тестовой сцены  
**Критерии приёмки:**
- Можно запустить тестовый проект и получить PNG через `/snapshot`.
- Снапшоты стабильны между прогонами (в пределах допусков).

### I2.2 Сравнение с golden (tolerance)
**Артефакты:** инструмент сравнения изображений (порог)  
**Критерии приёмки:**
- Изменение в рендере даёт понятный diff (файл/отчёт).
- Незначительные шумы (если есть) не фейлят тесты (по порогу).

---

## Epic I3 — Packaging / Export / Migrations
### I3.1 Проект как папка + Export as `.vtproj` (архив)
**Артефакты:** упаковщик, распаковщик, структура архива  
**Критерии приёмки:**
- Экспорт создаёт единый файл `.vtproj`.
- Импорт/открытие восстанавливает проект корректно.
- `.env` и `workspace.json` НЕ попадают в экспорт.

### I3.2 Миграции форматов и минимальная версия приложения
**Артефакты:** `minAppVersion`, миграции конфигов (скелет)  
**Критерии приёмки:**
- При открытии проекта с большей minAppVersion приложение отказывает с понятным сообщением.
- Для minor изменений есть мигратор (даже если пока пустой, но структура есть).

### I3.3 Плагины: глобальные и проектные пути
**Артефакты:** загрузчик плагинов из двух директорий  
**Критерии приёмки:**
- Плагин в глобальной папке грузится при старте.
- Плагин в проектной папке грузится при открытии проекта.
- Любая ошибка плагина не валит приложение (try/catch + лог).

---

# Дополнительно (полезные «закрывашки», чтобы MVP было удобно трогать)

## Epic X1 — Reference project (пример vtproj)
### X1.1 Минимальный vtproj с 1 камерой и 2 форматами
**Критерии приёмки:**
- Камера: 3D сцена + 2D персонаж слой.
- Форматы: `release` (16:9), `derived` (9:16), оба имеют overlay.
- `/api/streams` показывает оба формата.

### X1.2 Пример overlayProfile (debug/release теги)
**Критерии приёмки:**
- В debug профиле есть DebugHUD, в release нет.
- В overlay есть Text, Image, ProgressBar, FeedList с биндингами на DataStore.

## Epic X2 — Документация «как подключить OBS»
**Критерии приёмки:**
- Есть шаги: Browser Source на `/view/<formatId>/release` + токен (если remote).
- Есть фоллбек: Window Capture на окно формата.
- Есть рекомендации по FPS/качества (release 30fps q80, debug 15fps q60).

---

# Трассируемость (быстрая карта «из ТЗ → куда попало»)
- Рендер-цепочка URP (раздел 1 ТЗ) → **B2 + D4**
- Камеры/форматы/слои (раздел 2) → **B1**
- UI/Overlays (раздел 3–4) → **C1–C3 + E2**
- Streaming endpoints (раздел 5–6) → **D1–D3**
- Orchestrator (раздел 7) → **E1–E2**
- SceneCommand (раздел 8) → **F1**
- Плагины DLL (раздел 9) → **I3.3** (и каркас в A1.2)
- Интеграции/Rules (раздел 10) → **F2–F4**
- Трекинг (раздел 11) → **G1**
- Runtime vs Project state (раздел 12) → **A3**
- Templates/prefabs (раздел 13) → **(добавить при реализации Object.*)**  
- DataStore (раздел 14) → **A2**
- Replay (раздел 15) → **H1–H2**
- Тестирование (раздел 16) → **I1–I2**
- Packaging (раздел 17) → **I3**

---

## Чеклист готовности MVP (финальная приёмка)
1. **Demo vtproj** открывается на чистом ПК Windows.
2. `/api/health` и `/api/streams` работают без ошибок.
3. `/view/<formatId>/release` показывает картинку в OBS Browser Source.
4. Debug-профиль отличается (debug виджеты присутствуют).
5. On-demand: без потребителей CPU/GPU нагрузка падает, форматы «спят».
6. Hotkey или UI триггерит Replay и создаёт MKV файл.
7. Twitch/Webhook события приводят к SceneCommand и отражаются в audit.
8. Плагин с исключением не валит приложение (лог + продолжение работы).
9. Snapshot-тесты дают стабильный результат и ловят регрессии.
10. Export `.vtproj` работает, `.env` и `workspace.json` не попадают внутрь.

